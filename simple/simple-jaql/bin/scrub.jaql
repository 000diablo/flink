$dirty_earmarks = read(hdfs('UsEarmark.json'));
$earmarks = $dirty_earmarks -> transform {  
	// copies the value of the input record ($)
	$.earmarkId,
	// normalization with built-in function
	int($.amount * 1000),	
	sponsor: { // nested JSON type
		// normalization with user-defined function
		firstName: NormalizeName($.sponsorFirstName),
		lastName: NormalizeName($.sponsorLastName),
	},
};

$sponsors = $earmarks -> group by name = [$.sponsor.firstName, $.sponsor.lastName] into {
	firstName: name[0], 
	lastName: name[1], 
	earmarkId: $[*].earmarkId, 
	// predefined aggregation function on arrays
	addresses: distinct($[*].addresses), 
};

$members = read(hdfs('UsCongress_Members.json'));

$correspondences = link sponsor in $sponsors, 
        member in $members
	where jaccard($.lastName) >= 0.95 and 
		[ 5 * jaroWinkler($.lastName),
		  5 * jaroWinkler($.firstName)] >= 0.9 
	partition with SortedNeighborhood on 
		[ removeVowels($.lastName)[0:5], 
		  removeVowels($.firstName)[0:5]]
	into { sponsor.id, member.id };
    
$clusters = transitiveClosure($correspondences);

$sponsors = read(hdfs('UsEarmark_Sponsors.json'));
$members = read(hdfs('UsCongress_Members.json'));
$clusters = read(hdfs('CorrespondingPersons.json'));

fuse sponsors in $sponsors, members in $members
	where {sponsors[*].id, members[*].id} in $clusters
	into {
		id: GenerateId('person'),
		lastName: longest(vote($[*].lastName)),
		firstName: first(vote($[*].firstName)),
		addresses: MergeAddresses($[*].addresses),
		originalRecords: $[*].id, 
	}
	using weights {
		sponsors: 0.99,
		sponsors: {
			addresses: 0.7,
		},
		members: 0.99,
	}
-> write(hdfs('Persons.json'));

$funds = read(hdfs('Funds.json'));
$persons = read(hdfs('Persons.json'));

$funds -> substitute sponsor in $.sponsors
	using person in $persons
	where sponsor in person.originalRecords
	with person.id
-> write(hdfs('Funds.json'));



package eu.stratosphere.sopremo;

import eu.stratosphere.pact.common.contract.FileDataSinkContract;
import eu.stratosphere.pact.common.io.FileOutputFormat;
import eu.stratosphere.pact.common.plan.PactModule;
<<<<<<< HEAD
=======
import eu.stratosphere.sopremo.jsondatamodel.JsonNode;
>>>>>>> 082f89a35aa389ea6271765d2b5db6f13914f3ec
import eu.stratosphere.sopremo.pact.JsonOutputFormat;

public class Sink extends ElementaryOperator<Sink> {
	/**
	 * 
	 */
	private static final long serialVersionUID = -8917574029078139433L;

	private final String outputName;

<<<<<<< HEAD
	private Class<? extends FileOutputFormat<PactJsonObject.Key, PactJsonObject>> outputFormat;

	public Sink(Class<? extends FileOutputFormat<PactJsonObject.Key, PactJsonObject>> outputFormat,
			final String outputName) {
		super(0);
		this.outputFormat = outputFormat;
=======
	private final PersistenceType type;

	private final Class<? extends FileOutputFormat<JsonNode, JsonNode>> outputFormat;

	public Sink(final PersistenceType type, final String outputName, final JsonStream input) {
		this(JsonOutputFormat.class, outputName, input);
	}

	public Sink(final Class<? extends FileOutputFormat<JsonNode, JsonNode>> outputFormat,
			final String outputName, final JsonStream input) {
		super(input);
		// if (type == DataType.ADHOC)
		// throw new IllegalArgumentException();
>>>>>>> 082f89a35aa389ea6271765d2b5db6f13914f3ec
		this.outputName = outputName;
	}

	public Sink(final String outputName) {
		this(JsonOutputFormat.class, outputName);
	}

	public Sink() {
		this("");
	}

	public Class<? extends FileOutputFormat<PactJsonObject.Key, PactJsonObject>> getOutputFormat() {
		return this.outputFormat;
	}

	public void setOutputFormat(Class<? extends FileOutputFormat<PactJsonObject.Key, PactJsonObject>> outputFormat) {
		if (outputFormat == null)
			throw new NullPointerException("outputFormat must not be null");

		this.outputFormat = outputFormat;
<<<<<<< HEAD
=======
		this.type = PersistenceType.HDFS;
		this.setNumberOfOutputs(0);
>>>>>>> 082f89a35aa389ea6271765d2b5db6f13914f3ec
	}

	@Override
	public Output getSource() {
		throw new UnsupportedOperationException("Sink has not output");
	}

	@Override
	public PactModule asPactModule(final EvaluationContext context) {
		final PactModule pactModule = new PactModule(this.toString(), 1, 0);
<<<<<<< HEAD
		final FileDataSinkContract<PactJsonObject.Key, PactJsonObject> contract = new FileDataSinkContract<PactJsonObject.Key, PactJsonObject>(
=======
		final FileDataSinkContract<JsonNode, JsonNode> contract = new FileDataSinkContract<JsonNode, JsonNode>(
>>>>>>> 082f89a35aa389ea6271765d2b5db6f13914f3ec
			this.outputFormat, this.outputName, this.outputName);
		contract.setInput(pactModule.getInput(0));
		// if(this.outputFormat == JsonOutputFormat.class)
		contract.setDegreeOfParallelism(1);
		pactModule.addInternalOutput(contract);
		return pactModule;
	}

	@Override
	public SopremoModule toElementaryOperators() {
<<<<<<< HEAD
		SopremoModule module = new SopremoModule(this.getName(), 1, 0);
		Sink clone = (Sink) this.clone();
=======
		final SopremoModule module = new SopremoModule(this.getName(), 1, 0);
		final Sink clone = (Sink) this.clone();
>>>>>>> 082f89a35aa389ea6271765d2b5db6f13914f3ec
		module.addInternalOutput(clone);
		clone.setInput(0, module.getInput(0));
		return module;
	}

	public String getOutputName() {
		return this.outputName;
	}

	@Override
	public String toString() {
		return "Sink [" + this.outputName + "]";
	}

}
